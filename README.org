#+title: Liblouis release helpers

A script to generate some of the artifacts needed for a liblouis
release. In particular it creates

- An up-to-date ANNOUNCE file containing the news from NEWS
- a news post that can be inserted in the Jekyll based web site
- an up-to-date download index
- an up-to-date online documentation

* Usage

First build liblouis

#+BEGIN_SRC shell
cd ~/src/liblouis
make dist
#+END_SRC

Then run the release-helper script. Specify where the source to
liblouis and the liblouis website is located

#+BEGIN_SRC shell
clj -m release-helper ~/src/liblouis ~/src/liblouis.github.io
#+END_SRC

* Native Image

With the help of [[https://github.com/taylorwood/clj.native-image][clj.native-image]] you can build native images for the
scripts.

Install [[https://www.graalvm.org/downloads/][GraalVM]] and set ~$GRAALVM_HOME~.

#+BEGIN_SRC shell
export GRAALVM_HOME=/path/to/graalvm
clojure -A:native-image
./release_helper ~/src/liblouis ~/src/liblouis.github.io
#+END_SRC

Unfortunatelly at the moment GraalVM doesn't like some of the code.

#+BEGIN_EXAMPLE
Warning: Reflection method java.lang.Class.getMethod invoked at clojure.lang.Reflector.getMethods(Reflector.java:511)
Warning: Reflection method java.lang.Class.getMethods invoked at clojure.lang.Reflector.getAsMethodOfAccessibleBase(Reflector.java:240)
Warning: Reflection method java.lang.Class.getMethods invoked at clojure.lang.Reflector.getMethods(Reflector.java:535)
Warning: Reflection method java.lang.Class.getMethods invoked at clojure.lang.Reflector.getMethods(Reflector.java:498)
Warning: Reflection method java.lang.Class.getMethods invoked at clojure.lang.Reflector.getAsMethodOfAccessibleBase(Reflector.java:229)
Warning: Reflection method java.lang.Class.getFields invoked at clojure.lang.Reflector.getField(Reflector.java:487)
Warning: Aborting stand-alone image build due to reflection use without configuration.
#+END_EXAMPLE

** Reflection and resource configuration
As outlined in [[https://medium.com/graalvm/introducing-the-tracing-agent-simplifying-graalvm-native-image-configuration-c3b56c486271][Introducing the Tracing Agent]] you can help GraalVM with
a config file where you help it find classes normally found with
reflection.

First let the tracing agent analyse the program:

#+BEGIN_SRC shell
mkdir -p META-INF/native-image
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$GRAALVM_HOME/jre/lib/amd64
clj -J-agentlib:native-image-agent=config-output-dir=META-INF/native-image -m release-helper ~/src/liblouis ~/src/liblouis.github.io
#+END_SRC

Then clean up the generated files in ~META-INF/native-image~ by
removing some dynamically generated classes and specify the config
files in ~deps.edn~:

#+BEGIN_SRC clojure
  {:native-image
   {:main-opts ["-m clj.native-image release_helper"
		"--initialize-at-build-time"
		"-H:ReflectionConfigurationFiles=META-INF/native-image/reflect-config.json"
		"-H:ResourceConfigurationFiles=META-INF/native-image/resource-config.json"
		;; optional native image name override
		"-H:Name=liblouis_release_helper"]}}
#+END_SRC

Finaly build the native image:

#+BEGIN_SRC shell
clojure -A:native-image
#+END_SRC

It does build a native image, however it fails with an exception.
GraalVM seems to have a problem somewhere in java_time:

#+BEGIN_SRC shell
eglic@wharton:~/src/liblouis-release-helper$ ./release_helper ~/src/liblouis ~/src/liblouis.github.io
Exception in thread "main" java.lang.ClassCastException: java_time.graph.Types cannot be cast to java.lang.Comparable
	at clojure.lang.Util.compare(Util.java:153)
	at clojure.lang.APersistentVector.compareTo(APersistentVector.java:439)
	at java.util.concurrent.ConcurrentHashMap.compareComparables(ConcurrentHashMap.java:732)
	at java.util.concurrent.ConcurrentHashMap$TreeBin.<init>(ConcurrentHashMap.java:2773)
	at java.util.concurrent.ConcurrentHashMap.treeifyBin(ConcurrentHashMap.java:2630)
	at java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1063)
	at java.util.concurrent.ConcurrentHashMap.putIfAbsent(ConcurrentHashMap.java:1535)
	at java_time.potemkin.util$fast_memoize$fn__1405.invoke(util.clj:50)
	at java_time.graph$has_source_type_QMARK_$contains_src_types_QMARK___1715$fn__1716.invoke(graph.clj:279)
	at clojure.core$some.invokeStatic(core.clj:2701)
	at java_time.graph$has_source_type_QMARK_$contains_src_types_QMARK___1715.invoke(graph.clj:279)
	at clojure.core$some.invokeStatic(core.clj:2701)
	at java_time.graph$has_source_type_QMARK_.invokeStatic(graph.clj:282)
	at java_time.graph$fn__1742.invokeStatic(graph.clj:301)
	at java_time.graph$fn__1742.invoke(graph.clj:300)
	at java_time.potemkin.util$fast_memoize$fn__1405.invoke(util.clj:52)
	at java_time.graph$conversion_fn.invokeStatic(graph.clj:316)
	at java_time.local$local_date.invokeStatic(local.clj:12)
	at release_helper$to_date.invokeStatic(release_helper.clj:19)
	at release_helper$to_date.invoke(release_helper.clj:15)
	at clojure.core$map$fn__5870.invoke(core.clj:2760)
	at clojure.lang.LazySeq.sval(LazySeq.java:42)
	at clojure.lang.LazySeq.seq(LazySeq.java:51)
	at clojure.lang.RT.seq(RT.java:535)
	at clojure.core$seq__5402.invokeStatic(core.clj:137)
	at clojure.core$drop_while$step__5940.invoke(core.clj:2972)
	at clojure.core$drop_while$fn__5943.invoke(core.clj:2977)
	at clojure.lang.LazySeq.sval(LazySeq.java:42)
	at clojure.lang.LazySeq.seq(LazySeq.java:51)
	at clojure.lang.LazySeq.first(LazySeq.java:73)
	at clojure.lang.RT.first(RT.java:692)
	at clojure.core$first__5384.invokeStatic(core.clj:55)
	at release_helper$next_release_date.invokeStatic(release_helper.clj:29)
	at release_helper$next_release_date.invoke(release_helper.clj:29)
	at release_helper$next_release_date.invokeStatic(release_helper.clj:34)
	at release_helper$announcement.invokeStatic(release_helper.clj:66)
	at release_helper$_main.invokeStatic(release_helper.clj:154)
	at release_helper$_main.invoke(release_helper.clj:143)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.AFn.applyTo(AFn.java:144)
	at release_helper.main(Unknown Source)
#+END_SRC

** Reflection and resource configuration II

FIXME: The above is probably wrong as you should probably run the
tracing agent on a compiled jar.

#+BEGIN_SRC shell
mkdir -p META-INF/native-image
export JAVA_HOME=$GRAALVM_HOME
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$GRAALVM_HOME/jre/lib/amd64
$JAVA_HOME/bin/java -agentlib:native-image-agent=config-output-dir=META-INF/native-image -jar liblouis-release-helper-1.0.0-SNAPSHOT-standalone.jar ~/src/liblouis ~/src/liblouis.github.io
#+END_SRC

The generated files will not have to be cleaned up. Finaly build the native image:

#+BEGIN_SRC shell
clojure -A:native-image
#+END_SRC

It does build a native image, however it fails with the same
exception as above.


* Native Image II

I also tried to build a native image using [[https://github.com/luchiniatwork/cambada][Cambada]].

The native image builds as described in [[https://github.com/luchiniatwork/cambada#packaging-as-a-native-image][Packaging as a Native Image]].
There is no need to fidget with any resource files.

#+BEGIN_SRC clojure
{:aliases {:native-image
           {:extra-deps
            {luchiniatwork/cambada {:mvn/version "1.0.0"}}
            :main-opts ["-m" "cambada.native-image"
                        "-m" "release_helper"]}}}
#+END_SRC

#+BEGIN_SRC shell
$ clj -A:native-image
Cleaning target
Creating target/classes
  Compiling release-helper
Creating target/liblouis-release-helper
[target/liblouis-release-helper:15499]    classlist:   7,335.53 ms
[target/liblouis-release-helper:15499]        (cap):   3,880.57 ms
[target/liblouis-release-helper:15499]        setup:   6,412.06 ms
[target/liblouis-release-helper:15499]   (typeflow):   9,785.53 ms
[target/liblouis-release-helper:15499]    (objects):   4,690.54 ms
[target/liblouis-release-helper:15499]   (features):     737.32 ms
[target/liblouis-release-helper:15499]     analysis:  15,488.75 ms
[target/liblouis-release-helper:15499]     (clinit):     392.64 ms
[target/liblouis-release-helper:15499]     universe:     977.00 ms
[target/liblouis-release-helper:15499]      (parse):   2,318.94 ms
[target/liblouis-release-helper:15499]     (inline):   2,539.65 ms
[target/liblouis-release-helper:15499]    (compile):  15,378.09 ms
[target/liblouis-release-helper:15499]      compile:  21,142.38 ms
[target/liblouis-release-helper:15499]        image:   1,257.28 ms
[target/liblouis-release-helper:15499]        write:     788.60 ms
[target/liblouis-release-helper:15499]      [total]:  53,768.17 ms

Done!
#+END_SRC

However the resulting image fails even earlier:

Unfortunatelly at the moment GraalVM doesn't like some of the code.

#+BEGIN_EXAMPLE
eglic@wharton:~/src/liblouis-release-helper$ ./target/liblouis-release-helper ~/src/liblouis ~/src/liblouis.github.io
Exception in thread "main" java.lang.ExceptionInInitializerError
	at com.oracle.svm.core.hub.ClassInitializationInfo.initialize(ClassInitializationInfo.java:290)
	at java.lang.Class.ensureInitialized(DynamicHub.java:467)
	at clojure.lang.Namespace.<init>(Namespace.java:34)
	at clojure.lang.Namespace.findOrCreate(Namespace.java:176)
	at clojure.lang.Var.internPrivate(Var.java:153)
	at release_helper.<clinit>(Unknown Source)
	at com.oracle.svm.core.hub.ClassInitializationInfo.invokeClassInitializer(ClassInitializationInfo.java:350)
	at com.oracle.svm.core.hub.ClassInitializationInfo.initialize(ClassInitializationInfo.java:270)
	at java.lang.Class.ensureInitialized(DynamicHub.java:467)
Caused by: java.io.FileNotFoundException: Could not locate clojure/core__init.class or clojure/core.clj on classpath.
	at clojure.lang.RT.load(RT.java:463)
	at clojure.lang.RT.load(RT.java:426)
	at clojure.lang.RT.doInit(RT.java:468)
	at clojure.lang.RT.<clinit>(RT.java:336)
	at com.oracle.svm.core.hub.ClassInitializationInfo.invokeClassInitializer(ClassInitializationInfo.java:350)
	at com.oracle.svm.core.hub.ClassInitializationInfo.initialize(ClassInitializationInfo.java:270)
	... 8 more
#+END_EXAMPLE

* Rationale

Why do we need these scripts in the first place? Well, creating a
release is quite laborious but fairly mundane work as described in the
[[https://github.com/liblouis/liblouis/blob/master/HACKING][HACKING]] file. Automating most of this certainly makes sense.

On the other hand you can rightfully ask yourself why we are doing
this. The changes for example are listed in three different places
([[http://liblouis.org/][website]], [[https://github.com/liblouis/liblouis/releases][GitHub release page]], [[https://www.freelists.org/post/liblouis-liblouisxml/liblouis-3100-has-been-released][announce email]]) in two different
formats. Is this really needed?

Not having a separate website would certainly simplify things and
would partially obliviate the need for the release-helper scripts. At
the time it seemed easier for the user to have a website where all the
relevant information could be centrally organized, e.g. news,
downloads, online documentation, etc. The downloads have pretty much
been superseded by the GitHub releases page, but nightly snapshots are
still easier to find on the website.

Another simplification might be to have all changes in [[https://daringfireball.net/projects/markdown/][markdown]]. We
could put markdown in the announce email. That would mean no more
converting of formats. On the other hands I personally love editing in
[[https://orgmode.org/][orgmode]] and I would not want to miss it.


* Prerequisites

- You need the Clojure cli tools. Install them tools as described in
  the [[https://clojure.org/guides/getting_started][Getting Started Guide]].
- You need [[https://pandoc.org/][pandoc]].
- I recommend you use [[https://hub.github.com/][hub]] to create github releases from the command
  line

* Contributing
If you have any improvements or comments please feel free to file a
pull request or an issue.

* License

Copyright (C) 2019 Swiss Library for the Blind, Visually Impaired and Print Disabled

This library is free software; you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or (at
your option) any later version.

This library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this library; see the file COPYING. If not, write to the Free
Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
02110-1301 USA

